\chapter{Оптимизации}\label{ch:ch2}

В этой главе описаны разработанные оптимизации. Не все представленные оптимизации были приняты сообществом openEulerGCC \footnote{https://gitee.com/src-openeuler/gcc/} по разным причинам. Некоторые из описанных далее оптимизаций будут представлены сообществу позднее, а некоторые, возможно, будут заменены другими подходами. Тем не менее автор считает, что исследованные подходы также представляют научный интерес.


\section{Улучшение существующих оптимизаций}\label{sec:ch2/sect1}
\todo{ Написать введение}
\subsection{Свертка условных переходов}
Свертка условных переходов (If-conversion) — это хорошо известный метод оптимизации, который заменяет инструкцию перехода и зависящий от него поток управления, предикатным исполнением. В результате целевой код содержит меньшее количество инструкций перехода, что снижает нагрузку на аппаратный предсказатель переходов, однако такой подход увеличить количество избыточных инструкций во время исполнения \cite{bruel2021if}. Обычно эта оптимизация основана на представлении SSA, однако в компиляторе GCC используется другой подход. На этом этапе SSA форма отсутствует, что может привести к следующей проблеме (рис. \ref{fig:ifcvtsvg1}): если в одной из ветвей исполнения в качестве регистра назначения используется  тот же регистр (reg1 на
Рисунке \ref{fig:ifcvtsvg1}), что в другом в качестве источника, то после слияния будет создано неправильное определение reg1.

Предлагаемое решение содержит принудительное переименование регистров. Такая трансформация была добавлена при коллизии такого типа. Регистры коллизий определяются как:

$$rename\_candidates = DEFS_{left\_bb} \cap USES_{right\_bb} $$
Если $rename\_candidates[i]$ все еще жив в конце базового блока $BB$, то трансформация не может быть применена.


\begin{figure}[htbp]
	\centering

	\includesvg[width = 400pt, inkscapelatex=false ]{SVG/ifcvt-1.svg}
	\caption{Пример некоректной свертки условных переходов в следствие отсутствия SSA формы.}
	\label{fig:ifcvtsvg1}
\end{figure}

Улучшение свертки условных переходов в компиляторе GCC было размещено под опцией \mbox{\textbf{-fifcvt-allow-register-renaming}}. Такой подход помогает уменьшить количество "хвостовых" базовых блоков в целевых тестах. (Листинг \ref{ifcvtcode1}). 

\begin{ListingEnv}[!h]
	\captiondelim{ } % разделитель идентификатора с номером от наименования
		\caption{Пример "хвостовых" базовых блоков, которые будут оптимизированы предложенным улучшением свертки условных переходов.}
	\label{ifcvtcode1}
	\begin{Verb}
		4145bc:   ret
		4145c0:   mov     x5, #0x100000000              
		4145c4:   add     x7, x7, x5
		4145c8:   b       4131d0
		4145cc:   mov     x2, #0x100000000               
		4145d0:   add     x6, x6, x2
		4145d4:   b       4145a0 
		4145d8:   mov     x3, #0x100000000                
		4145dc:   add     x11, x11, x3
		4145e0:   b       41454c
		4145e4:   mov     x3, #0x100000000 
		4145e8:   add     x11, x11, x3
		4145ec:   b       4144fc 
	\end{Verb}
\end{ListingEnv}

\subsection {Векторизация циклов с небольшим числом итераций}
Векторизация — это известный метод, использующий параллелизм данных \cite{nuzman2006autovectorization}. В ходе текущего исследования было обнаружено, что векторизация генерирует хвосты (т. е. векторизованный код для меньшего коэффициента векторизации), но не использует их, когда фактическое количество итераций равно коэффициенту векторизации хвоста ($VEC\_FACTOR$). Следовательно, когда ($VEC\_FACTOR$) пложен, например 8, код будет сгенерирован для $VEC\_FACTOR = 4$ и $VEC\_FACTOR = 2$. Если во время выполнения фактическое количество итераций будет только 4, то будет выбран скалярный вариант. Это небольшое и простое улучшение меняет условие пересечения указателя в заголовке цикла.

Рассмотрим простой цикл (Листинг \ref{algexample_1})

\begin{ListingEnv}[!h]
	\captiondelim{ } % разделитель идентификатора с номером от наименования
	\caption{Простой цикл рассматриваемый оптимизацией векторизации.}\label{algexample_1}
	\begin{Verb}
		\\ a,b,c: any arrays with size N
		for (i = 0; i<N; i+=1)
		    c[i] = a[i] *b[i]
	\end{Verb}
\end{ListingEnv}
GCC преобразует этот цикл в (Листинг \ref{vectorized_loop_example}), и легко видеть, что если, например, $c-a = VEC\_FACTOR/2$ и $N = VEC\_FACTOR/2$, то будет выбрана скалярная версия.

\begin{ListingEnv}[!h]
	\captiondelim{ } % разделитель идентификатора с номером от наименования
	\caption{Цикл (Листинг \ref{algexample_1}) после векторизации GCC}\label{vectorized_loop_example}

	\begin{Verb}

		\\ a,b,c: any arrays with size N
		VEC_FACTOR: factor estimated by GCC pass
		if  (abs (c - a) < VEC_FACTOR  ||  
		     abs (c - b) < VEC_FACTOR) 
		    goto SCALAR;

		if (N < VEC_FACTOR)
		    goto TAIL;
			
		for (i;i<N;i+=VEC_FACTOR)
		    WIDE_C = WIDE_A * WIDE_B 
		    \\ WIDE_X has VEC_FACTOR size 
			
		TAIL:
		if (i<N - VEC_FACTOR/2)
		    goto SCALAR;
			
		SEMIWIDE_C = SEMIWIDE_A * SEMIWIDE_B 
		\\ SEMIWIDE has VEC_FACTOR/2 size 
		
		SCALAR:
		for (i = 0; i<N; i+=1)
		    c[i] = a[i] *b[i]

	\end{Verb}
\end{ListingEnv}

\begin{ListingEnv}[!h]
	\captiondelim{ } % разделитель идентификатора с номером от наименования
	\caption{Модифицированная проверка для (Листинг \ref{vectorized_loop_example})}\label{replaced_check}
	
	\begin{Verb}
		
		
		\\ a,b,c: any arrays with size N
		\\ VEC_FACTOR: factor estimated by GCC pass
		if (abs (c - a) < min(VEC_FACTOR,N) ||
		    abs (c - b) < min(VEC_FACTOR,N)) 
		   goto SCALAR;
	\end{Verb}
\end{ListingEnv} 

Чтобы это исправить, предлагается простое решение: заменить строки 1 и 2 в векторизованной версии (Листинг \ref{vectorized_loop_example}) следующим кодом (Листинг \ref{replaced_check}). Добавлен параметр \textbf{--param=vect-alias-flexible-segment-len}. Эта оптимизация повышает производительность приложения x264.




\section{Шаблонные оптимизации}\label{sec:ch2/sect2}
\todo{ Написать введение}
\subsection{Оптимизация двойного умножения}
Оптимизация двойного умножения — это шаблонное преобразование компилятора, предназначенное для преобразования алгоритма 64-битного умножения в  эффективные инструкции. Таким образом, программа может лучше использовать возможности аппаратуры и повысить производительность всего приложения. Это стандартная архитектурно-зависимая оптимизация. Различные архитектуры предоставляют разные наборы команд. Иногда инструкции системы команд просты, что позволяет легко найти аналоги для любой архитектуры (например, инструкция add), но иногда, особенно в CISC-архитектурах, могут встречаться достаточно сложные инструкции, эквивалент которых потребует десятков и даже сотен команд.  \cite{bansal2021reduced, isen2009tale}.


Идея таких вычислений основана на максимальных значениях половинного умножения ($s$ - размер в битах).
\begin{equation*} \label{eq1}
	\left(2^{s/2}-1\right)^2=2^s-2^{s/2+1}+1<2^s-1
\end{equation*}

При разделении аргументов на части $s/2$ широкое умножение можно переписать как:
\begin{equation*} \label{eq2}
	\begin{split}
		res& =a\cdot b =\left(2^{s/2}a_{hi}+a_{lo}\right)\left(2^{s/2}b_{hi}+b_{lo}\right) \\
		& =2^sa_{hi}b_{hi}+2^{s/2}\left(a_{hi}b_{lo}+a_{lo}b_{hi}\right)+a_{lo}b_{lo}  
	\end{split}
\end{equation*}
Результат состоит из двух частей: нижней (от $1$ до $2^s - 1$) и верхней (от $2^s$ до $2^{2s} -1$). Первое слагаемое  и старшая часть второго слагаемого станут старшей частью результата. Нижняя часть второго и третьего слагаемых станут  нижней частью результата.


\begin{equation*} \label{eq3}
	\begin{split}
		2^s\le2^sa_{hi}b_{hi}<2^{2s}
	\end{split}
\end{equation*}
\begin{equation*} \label{eq4}
	\begin{split}
		2^{s/2}& \le2^{s/2}\left(a_{hi}b_{lo}+a_{lo}b_{hi}\right)\\ 
		& \le2^{3s/2}\left(2^{s+1}-2^{s/2+2}+1\right)
	\end{split}
\end{equation*}
\begin{equation*} \label{eq5}
	\begin{split}
		1\le a_{lo}b_{lo}<2^s
	\end{split}
\end{equation*}
Несложно доказать, что сложения могут привести к переполнению во время этих вычислений. Переименуем слагаемые для лучшей читабельности:
\begin{equation*} \label{eq6}
	\begin{split}
		mid\_res&=a_{hi}b_{lo}+a_{lo}b_{hi} \\
		&=mid\_res\_real+mid\_res\_overflow
	\end{split}
\end{equation*}
\begin{equation*} \label{eq7}
	\begin{split}
		res_{lo}&=2^{s/2}mid\_res\_real_{lo}+a_{lo}b_{lo} \\
		&=res\_low\_real+res\_low\_overflow
	\end{split}
\end{equation*}

\begin{flalign*}  \label{eq8}
	res_{hi}&=middle\_res\_real_{hi}+a_{hi}b_{hi} \notag  \\
	&=res\_high\_real+\dfrac{res\_low\_overflow}{2^s}\\
	&\phantom{=res\_high\_real}+\dfrac{mid\_res\_overflow}{2^{s/2}} \notag 
\end{flalign*}



\begin{equation*} \label{eq9}
	res=2^s \cdot res_{hi}+res_{lo}
\end{equation*}

Все вычисления сопоставляются с использованием существующего механизма сопоставления шаблонов GCC и преобразуются в одиночные умножения более широких типов. Количество инструкций значительно уменьшено. На CPUBench наблюдалось улучшение производительности на 30 \% в тесте OpenSSL.

\subsection{Шаблонная криптография}
В этом разделе поднимается важная тема для различных встраиваемых устройств и расширений архитектуры. В современном мире существует множество специализированных устройств для конкретных задач; например, ускорители для нейронных сетей \cite{chen2020survey}, для научных вычислений \cite{weber2010comparing}, для обработки графов \cite{rahman2020graphpulse} и т. д.

В недавнем исследовании \cite{peccerillo2022survey} Pecceriilo et al., 2022, классифицировали около 100 различных типов
ускорителей. Таким образом, в этой тенденции компилятор становится очень практичным инструментом, который может компилировать (потенциально автоматически) и планировать выполнение задач на разных устройствах. В настоящее время разные компании пытаются разработать собственный подход к решению этой задачи \cite{tavarageri2019automatic,chen2022case,kovac2022towards}.

Небольшая часть этой глобальной проблемы была решена в ходе нынешнего исследования. Kunpeng 920 имеет на плате расширение криптографии, которое включает специальные инструкции для crc32 и AES. Их можно использовать напрямую через встроенный язык ассемблера или встроенные функции компилятора. Добавлены оптимизации компилятора, которые могут определять возможность использования инструкций в соответствии с семантикой кода.

Оптимизация соотносит весь алгоритмам, включая предварительно рассчитанные таблицы, и статически проверяет, что все предварительно рассчитанные таблицы не изменяются во время выполнения. Оптимизация контролируется флагами \textbf{-fcrypto-accel-aes} и \textbf{-fcrypto-accel-crc32}. Оба шаблона были реализованы внутри RTL, поскольку они являются  архитектурно-зависимыми. На верхнем уровне логика оптимизаций очень похожа друг на друга. Следующие шаги описывают преобразование шаблона AES:

\begin{enumerate}
	\item \textbf{Сбор ссылок на таблицы AES}: Разработан оптимизационных проход внутри компилятора GCC для поиска ссылки на соответствующие таблицы шифрования/дешифрования AES. Такие инструкции являются отправной точкой для дальнейшего анализа.
	\item \textbf{Формирование раундов AES}: Анализируются ссылки на таблицы и собираются инструкции, выполняющие вычисления, относящиеся к AES. связывая их вместе в блоки и раунды.
	\item \textbf{Проверка шаблона AES}: Анализируются раунды и связываются вместе.
	\item \textbf{Генерация кода AES}: Генерируется код AES для всех найденных раундов.
\end{enumerate}

Для сопоставления внутреннего представления компилятора на уровне RTL использовался собственные шаблонный анализатор.Механизм сопоставления был создан на основе существующих генераторов сопоставлений match.pd GENERIC и GIMPLE.  Код для необходимой проверки шаблона генерируется во время компиляции GCC. Анализатор генерирует заранее упорядоченную последовательность аргументов.


Специальные инструкции сократили общее количество инструкций в целевых горячих циклах, что привело к значительному ускорению. Улучшение производительности на 10+ \% было достигнуто на
тестах openSSL и gzip.

К сожалению, оптимизация crc32 не была принята, поскольку менее общая оптимизация, обеспечивающая большую производительность при использовании gzip, была предложена другими авторами.

\subsection{Шаблонная подстановка инструкций}

Одной из основных основных задачей компилятора является выбор наиболее подходящих инструкций которыми можно будет наиболее лаконично и в то же время оптимально с точки зрения производительности выразить внутреннее представление программы \cite{blindell2016instruction}. В данной работе  не изменяется работа стандартного прохода выбора инструкций, однако добавляется несколько небольших шаблонов, который способствуют лучшей утилизации набора команд архитектуры ARM64.

Так арифметическое выражение вида 
\begin{flalign*}  \label{eq10}
	B = (((A &>> 15) \& 0x00010001) << 16) -\\
	((A &>> 15) \& 0x00010001)
\end{flalign*}

до внесенных изменений транслировалось в векторной версии в (Листинг \ref{unoptimal1}) может быть транслировано в (Листинг  \ref{optimal1})
\begin{ListingEnv}[!h]
	\captiondelim{ } % разделитель идентификатора с номером от наименования
	\caption{Пример неоптимального выбора инструкций №1}\label{unoptimal1}
	
	\begin{Verb}
			xtn v18.4h, v17.4s
			xtn2 v18.8h, v1.4
	\end{Verb}
\end{ListingEnv} 
\begin{ListingEnv}[!h]
	\captiondelim{ } % разделитель идентификатора с номером от наименования
	\caption{Оптимальный выбор инструкций для Листинга \ref{unoptimal1} }\label{optimal1}
	\begin{Verb}
			uzp1 v17.8h, v18.8h, v17.8h
	\end{Verb}
\end{ListingEnv} 

Таким  же методом был преобразован код  (Листинг \ref{unoptimal2}) в более оптимальную версию, использующую инструкции smin/smax на (Листинг \ref{optimal2})
\begin{ListingEnv}[!h]
	\captiondelim{ } % разделитель идентификатора с номером от наименования
	\caption{Пример неоптимального выбора инструкций №2 }\label{unoptimal2}
	\begin{Verb}
			sshr v1.4s, v1.4s, #10
			neg v24.4s, v1.4s
			mov v20.16b, v1.16b
			sshr v24.4s, v24.4s, #31
			bic v20.4s, #0xff
			cmeq v20.4s, v20.4s, #0
			bif v1.16b, v24.16b, v20.16b
	\end{Verb}
\end{ListingEnv} 
\begin{ListingEnv}[!h]
	\captiondelim{ } % разделитель идентификатора с номером от наименования
	\caption{Оптимальный выбор инструкций для Листинга \ref{unoptimal2} }\label{optimal2}
	\begin{Verb}
		movi v2.2d, #0x0 // (outside the loop)
		movi v3.2d, #0xff000000ff // (outside the loop)
		...
		smax v18.4s, v18.4s, v2.4s // (inside the loop)
		smin v18.4s, v18.4s, v3.4s // (inside the loop)
		uzp1 v17.8h, v18.8h, v17.8h
	\end{Verb}
\end{ListingEnv} 



\section {Девиртуализация}

Современные языки программирования с высоким уровнем абстракции, такие как Java, С++ и C\#, используют динамические таблицы вызовов для реализации полиморфизма. \cite{calder1994quantifying,suganuma2000overview,bauer2021novt} В этой схеме адрес вызываемой функции определяется только во время выполнения программы. Виртуальные функции в объектно-ориентированных языках программироания являются одним из основных источников косвенных переходов в программах. Также в языках C/C++ можно использовать указатели на функции, а в GCC доступны указатели на метки внутри программы \cite{shah1995function}. Такой метод программирования позволяет пользователю создавать косвенные вызовы и переходы. Однако нетривиальное выполнение инструкций управления может замедлить работу центрального процессора, так как для эффективной обработки инструкций управления суперскалярному процессору необходимо предсказывать целевой адрес перехода. Для этого используются специальные устройства-предсказатели \cite{mcfarling1993combining,mittal2019survey}. Однако, предсказание косвенного перехода отличается от предсказания условного, так как в первом случае конечных адресов может быть множество и их необходимо хранить в памяти предсказателя. Это может потребовать лишней площади на кристалле \cite{driesen1998accurate}. Существующие методы разработки аппаратуры позволяют использовать принцип виртуального счетчика инструкций, но такой подход все равно требует дополнительной логики непосредственно в аппаратуре \cite{redmond2007vpc}.

Текущие подходы к решению данной задачи в основном фокусируются на разрешении вызовов виртуальных функций для объектно-ориентированного программирования \cite{namolaru2006devirtualization,padlewski2017devirtualization}. Отсутствие информации о целевых функциях в графе вызова затрудняет межпроцедурные оптимизации и делает невозможной подстановку функций непосредственно в код, что существенно ограничивает оптимизационные возможности компилятора \cite{li2010lightweight,pande1996data}.


В статье \cite{chernonog2023статический} описывается два метода преобразования косвенных переходов: статический и динамический.  

Статический метод по своей сути является расширением стандартной методологии девиртуализации компилятора GCC. Его работа разделена на две части:

\begin{enumerate}
	\item \textbf{Анализ сигнатур функций}: Авторами предлагается анализировать сигнатуры функций для определений и вызовов. Если сигнатура вызываемой функции совпадает с сигнатурой определения то функция определения считается кандидатом.
	\item \textbf{Трансформация косвенного перехода}: На этом этапе, в случае единственного кандидата, косвенный вызов функции заменяется вызовом найденной процедуры. Если же кандидатов несколько, то приходится выстраивать цепочку сравнений адресов переходов. что не всегда является оптимальным
\end{enumerate}


\begin{figure}[ht]
	\centerfloat{
		\includegraphics[scale=1]{PNG/ICP}
	}
	\caption{Пример замены косвенного вызова.}\label{fig:ICP1}
\end{figure}

С другой стороны динамический метод использует информацию, собранную во время выполнения программы \cite{baev2015profile,ishizaki2000study}, чтобы изменить косвенные переходы, не требуя повторной компиляции программы, как это происходит при использовании профилирования, или системы JIT-компиляции (Just-in-Time compilation). Для решения этой проблемы предлагается встраивать средства трансформации кода непосредственно в исполняемую программу. В случае систем JIT, перекомпилированный код отдельного метода или функции обычно помещается во вновь выделенный участок памяти \cite{cravvford1988study}. Однако здесь предлагается использовать единый участок памяти, изменяя его содержимое во время исполнения.

\textbf{Алгоритм}
 \begin{enumerate}
 	\item \textbf{Выбор косвенных переходов}:В ручном режиме в исходном коде программы  необходимо обернуть косвенный вызов или переход типа goto специальными библиотечными макро-определениями "DDL\_GOTO" или "DDL\_CALL". При использовании автоматического режима компиляятор на основе графа вызовов принимает решение о применении оптимизации. 
 	\item \textbf{Трансформация косвенных переходов}:Вместо каждой инструкции перехода генерируется "окно" в виде заранее определенного количества nop инструкций и вызовов библиотечных функций сбора статистики и замены инструкций nop условными переходами при превышении счетчиков. Оригинальный косвенный переход несомненно сохраняется в самом конце.
 	\item \textbf{Запуск программы и сбор статистики}: Этот этап и все последующие  выполняются в ходе работы программы (и не требуют каких-либо действий со стороны пользователя или компилятора). Каждый раз, когда программа достигает модифицированного косвенного перехода, вызывается библиотечная функция для обновления статистики целевых адресов этого перехода. Библиотека  накапливает статистику отдельно для каждого перехода, который идентифицируется по уникальному номеру, присвоенному при инициализации.
 	\item \textbf{Трансформация в реальном времени} . Когда собранно достаточное количество статистической информации (которое задается параметром N), запускается функция модификации кода программы. Целевые адреса сортируются в порядке уменьшения количества совершенных по ним переходов. Если 95 \% переходов происходит не более чем по k адресам, то выполняется замена цепочки nop инструкций на условные переходы (листинг \ref{indirect_algo1}). В противном случае происходит вставка исходного косвенного перехода.
	\item \textbf{Работа оптимизированного перехода}: После преобразования перехода, режим сбора статистики целевых адресов отключается. Однако информация о количестве выполнений данного перехода продолжает накапливаться, а также записывается количество случаев, когда в преобразованном коде отсутствует прямой переход по полученному целевому адресу, и должен сработать первоначальный косвенный переход (который находится дальше по коду), то есть оптимизация для полученного адреса не произведена. Если количество пропущенных переходов станет значительным по сравнению с общим числом входов в данный участок кода, то цепочка прямых условных переходов будет заменена первоначальным блоком nop инструкций, и снова будет запущен сбор статистики. Другими словами, будет выполнен переход к шагу 2. При этом статистика адресов, собранная на предыдущем этапе выполнения шага 3, учитывается с коэффициентом 0.5, что позволяет сохранить эту информацию.
 \end{enumerate}

\begin{ListingEnv}[!h]
	\captiondelim{ } % разделитель идентификатора с номером от наименования
	\caption{Псеводкод преобразованного косвенного перехода)}\label{indirect_algo1}
	
	\begin{Verb}
		
		INT entry_count = 0;
		entry_count++;
		START_REWRITE_POINT:
		NOP
		NOP
		...
		NOP // k-times reapeat
		BOOL collect_stat_mode = FALSE;
		INT miss_count = 0;
		miss_count++;
		if ( entry_count == N)
		&& (miss_count > entry_count >> 4) {
			if (!collect_stat_mode){
				collect_stat_mode = TRUE;
				CALL DDL_DISABLE_OPTIMIZATON();
			} else {
				miss_count = 0;
				entry_count = 1;
				CALL DDL_REWRITE_INDIRECT();
				collect_stat_mode = FALSE;
			}
		}
		if (collect_stat_mode) {
			CALL DDL_UPATE_STATISTICS();
		}
		goto *addr; // original indirect branch
		
	\end{Verb}
\end{ListingEnv} 


\begin{ListingEnv}[!h]
	\captiondelim{ } % разделитель идентификатора с номером от наименования
	\caption{пример преобразованного на ходу косвенного перехода])}\label{indirect_algo2}
	
	\begin{Verb}
		
mov       w9 #0xe20
movk      w9 #0x40, lsl #16
cmp       x28, x9
b.eq      0x400e20
movk      w9, #0xe60
cmp       x28, x9
b.eq      0x400e60
movk      w9, #0xe30
cmp       x28, x9
b.eq      0x400e30
movk      w9, #0xe40
cmp       x28, x9
b.eq      0x400e40
movk      w9, #0xe50
cmp       x28, x9
b.eq      0x400e50
movk      w9, #0xdd4
cmp       x28, x9
b.eq      0x400dd4
movk      w9, #0xe10
cmp       x28, x9
b.eq      0x400e10
nop
nop
...
	\end{Verb}
\end{ListingEnv} 

Статический подход способствовал улуччшению тестов tpcc и tpch. Хотелось бы отметить, что улучшение opensssl в статье \cite{chernonog2023статический} ошибочно и является следствием некачественной валидации бенчмарка openssl в пакете CPUBench, а также со стороны авторов.

Динамический подход не показал эффективности на целевых тестах, однако на небольшых тестах, разработанных самостоятельно наблюдается улучшение производительности до 200 \%, когда количество адресов перехода находится в диапазоне от 4 до 8, в иных случаях может наблюдаться деградация. Деградация в 10 \% также наблюдалась на отдельных тестах пакета SPEC2017.

\begin{figure}[ht]
	\centerfloat{
		\includegraphics[scale=0.6]{PNG/ICP2}
	}
	\caption{Результаты замеров производительности динамического подхода в зависимости от распределения количества целевых адресов.}\label{fig:ICP2}
\end{figure}


 \section {Разбиение широких инструкций доступа в память} \label{ch2:split_ldp_stp}
Архитектура ARM имеет сложные инструкции, которые выполняют содержат внутри себя несколько простых , например арифметических или логических операций. Такие инструкции позволяют эффективно использовать ресурсы ЦПУ и уменьшают размер кода. Они повышают производительность и сокращают задержку выполнения операций. Однако для использования сложных инструкций необходимо тщательно понимать их функциональность и ограничения, чтобы обеспечить более качественное выполнение программы. Предыдущие исследования \cite{park2019microarchitecture} показали, что разделение 128-битных инстирукицй чтения из памяти  может улучшить производительность на отдельных тестах. В ходе данного исследования была продолжена эта работа, и было обнаружено, что в двух случаях использование широкого доступа к памяти может снизить производительность.

\begin{figure}[htbp]
	\centering
	\includesvg[width = 400pt, inkscapelatex=false ]{SVG/split_ldr.drawio.svg}
	\caption{Два случая, когда использование широкого доступа в память приводит к замедлению.}
	\label{splitsvg1}
\end{figure}

Один из них (см. рисунок \ref{splitsvg1}) - это хорошо известный не выравненный доступ. Было выявлено, что широкий доступ к памяти должен быть выровнен по его размеру, в противном случае производительность снижается (даже когдла речь идет о загрузке 2х независимых регистров). С другой стороны, было показано, что Kunpeng 920 не может быстро обрабатывать зависимости чтения после загрузки в память, если они имеют разные размеры. По всей видимости аппаратная оптимизация пересылки сохраняемого значения (store-to-load forwarding) \cite{shen2013modern} не может быть выполнена в таком случае. Поэтому было решено разделить широкие доступы к памяти в эмпирически установленном диапазоне.



\begin{figure}[htbp]
	\centering
	\includesvg[width = 300pt, inkscapelatex=false ]{SVG/wide_ldr.svg}
	\caption{Cхема алгоритма разделения сложных инструкций.}
	\label{splitsvg2}
\end{figure}

Для решения этой проблемы был разработан алгоритм (см. рисунок \ref{splitsvg2}), который находит инструкцию определения для базового регистра адреса широкой загрузки. Затем алгоритм ищет все использования этого определения, кроме оригинального. Если алгоритм находит сохранение в память с той же базой, то проверяется целесообразность разделения исходного широкого доступа к памяти. Было предположено, что такой подход разумен, если расстояние между загрузкой и сохранением составляет менее 16 инструкций.

 \section {Уменьшение размеров типов переменных}
 Анализ диапазона значений переменных в компиляторе \cite{harrison1977compiler,  simon2008value}  может помочь в удалении избыточных условий, улучшении постоянного распространения, удалении избыточных вычислений и т. д. В результате исследования было выявлено, что анализ диапазона значений GCC все еще имеет недостатки. Прежде всего, текущая оптимизация распространение диапазона значений не способна получать диапазоны из неизменяемых структур данных, что может быть полезно для предварительно вычисленных таблиц. Кроме того, GCC не может изменить размер переменной. Например, если диапазон переменной - $\{0, 1\}$, но пользователь использует тип \textbf{int} для нее, это неоднозначно, для этого можно использовать тип \textbf{boolean}, то же самое касается \textbf{int64\_t} и \textbf{int32\_t}. К сожалению, это не относится к переменным с плавающей точкой, потому что точность может быть потеряна. Производительность на тесте gzip была улучшена.
 
 \section {Векторизация ленивых вычислений}
 Ленивые вычисления в языках С/C++ являются частью стандарта языка. Такой подход помогает оптимизировать программы в том смысле, что необходимые вычисления производятя только в тот момент, когда они нужны, а не заранее \cite{cukic2018functional}. Например, в строке (if (pointer \&\& pointer[idx] > 0)) загрузка из памяти гарантированно  не будет выполнена до того момента, как значение указателя не проверится на отличие от нуля. 
 
 Однако такой подход может давать замедление производительности в некоторых случаях.
 Так например в лиcтинге \ref{lcv1} такой подход приводит к замедлению исполнения программы из-за того, что в оно суперскалярного процессора помещается слишком мало инструкций.
 
 \begin{ListingEnv}[!h]
 	\captiondelim{ } % разделитель идентификатора с номером от наименования
 	\caption{Кандидат для векторизации ленивых вычислений}\label{lcv1}
 	
 	\begin{Verb}
... code ...
if (arr[len] != const1 || arr[len +1] != const2 
	|| arr[len+2] != const3  || arr[len+3] != const4) {
		/* some code */
	}
... code ...
 	\end{Verb}
 \end{ListingEnv}
 
 Тем не менее векторизация такого участка кода может привести к выходу за границу массива, и в случае выхода за границу выделенной границы памяти может произойти исключительная ситуация seegmentation fault. Чтобы этого избежать предлагается добавить в компиллятор знание о страничном устройстве памяти. Обладая этим знанием компилятор может разрешить программе производить чтение за пределами массива, если достоверно известно, что эта страница доступна  программе во время исполнения. Тогда предлагается следующая схема (см рис. \ref{lcv2}):
Перед входом в векторизованный код вставляется проверка на доступность всех ячеек памяти. Т.е  динамически проверяется, что все доступы в память находятся в одной странице памяти. Если условие выполняется, то исполняется векторизованная версия кода, если же нет, то выбирается оригинальная версия.
 
 \begin{figure}[htbp]
 	\centering
 	\includesvg[width = 400pt, inkscapelatex=false ]{SVG/lcv.svg}
 	\caption{Схема векторизации ленивых вычислений].}
 	\label{lcv2}
 \end{figure}
 
 Данный подход вставляет в код одну дополнительную проверку, следовательно в некоторых случаях время исполнения программы может увеличится, однако на целевых тестах такого не наблюдалось, наоборот, наблюдалось ускорение теста gzip.