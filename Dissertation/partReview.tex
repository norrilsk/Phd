\chapter{Обзор существующих технологий оптимизации под ARM64}\label{ch:chReview}
Первая глава содержит обзор существующих оптимизаторов для архитектуры ARM64. Классические и известные компиляторные оптимизации (такие как удаление мертвого кода, поиск общих подвыражений, ленивое перемещение кода и подобные) не подлежат рассмотрению по своей сути, однако, подлежат рассмотрению их модификации, которые позволяют получить улучшение производительности для архитектуры ARM64. 

GCC является одним из наиболее известных статических трансляторов кода \cite{gough2004introduction}. Количество оптимизирующих проходов этого компилятора исчисляется сотнями и тем не менее его улучшение происходит до сих пор и каждый год обнаруживаются новые возможности для оптимизации даже в классических проходах \cite{theodoridis2022finding}. Другим популярным транслятором с открытым исходным кодом является  компилятор clang на базе llvm, который тоже не лишен недостатков \cite{zhou2021empirical}.


\section{Распределение регистров}
Распределение регистров наравне с выбором и расстановкой инструкций является одной из самых сложных оптимизаций в компиляторе \cite{lozano2019survey, alfred2007compilers}. Так как задача распределения регистров является NP-полной, то часто найденное компилятором решение является не оптимальным. Так, например, в исследовании  \cite{melnik2010case} было обнаружено, что лишние инструкции загрузки из памяти могут генерироваться в следствие неточности округлений, связанных с использованием целочисленных вероятностей в компиляторе GCC. 

Интересное решение было предложено Яном Роджерсом \cite{rogers2020efficient}. В своей статье он вводит такое понятие, как "активная в будущем" переменная, объединяя модели линейного сканирования и анализа жизни позволяет лучше проводить глобальное распределение регистров. 

Решение  NP-полных задач чаще всего предполагает эвристический подход, по этому нередки случаи использования методов машинного обучения, в частности обучения с подкреплением для распределения регистров \cite{venkatakeerthy2023rl4real}, что позволило авторам получить улучшение производительности на целевых тестах в виде spec2017 вплоть до 4-5 \% на отдельных программах.


\section{Векторизация}
Векторизация - вид распаралелливания программы, при котором однопоточное приложение, выполняющее одну операцию за единицу машинного времени, модифицируется для выполнения нескольких однотипных простых операций за раз. При этом простые скалярные операции заменяются векторными аналогами, способными производить операции над массивом данных. Чаще всего векторизацию подразделяют на цикловую и линейную. \cite{pohl2018control} В процессорах семейства ARM64 существует несколько векторных расширений: NEON, SVE, SVE2.

В работе Angela Pohl etc. \cite{pohl2018control} рассматривается генерация эффективного векторного кода на примере 151 цикла. Авторы утверждают, что основной  преградой для векторизации является сложная структура графа потока управления, которая препятствует стандартным алгоритмам векторизации кода. 
 Так, например в  листинге \ref{review_vec1} исполнение условия является управлением, препятствующим векторизации.
  \begin{ListingEnv}[!h]
 	\captiondelim{ } % разделитель идентификатора с номером от наименования
 	\caption{Пример цикла, содержащего управления}\label{review_vec1}
 	
 	\begin{Verb}
 		int arr[n], a[n],  b[n], out[n];
 		... code ...
 		for (int i = 0; i< n; i++) {
 			if (cond1[i] & cond2[n-1]){
 				out[i] = a[i] + b[i];  
 			}
 		}
 		... code ...
 	\end{Verb}
 \end{ListingEnv}
 
Авторы предлагают встраивать динамическую проверку, которая  отвечает на вопрос, находится ли массив в единственной странице физической памяти. Накладные расходы остаются минимальными поскольку проверка вставляется единожды вне цикла. В главе \todo{ XXX} будет рассмотрено улучшение этого подхода, когда встраивание проверки вне цикла невозможно.
 
Другое направленике, которое стоит отметить это библиотечная векторизация функций. Так, например, векторизация стандартных  математических функций \cite{petrogalli2018llvm} позволяет добить значительного ускорения незримо для пользователя. К сожалению, такой подход не позволит векторизовать математическую функцию,написанную собственноручно.
 
 
\section{Предзагрузка данных}
Эффективное управление данными является одним из ключевых аспектов производительности целевого приложения. Известно, что время доступа в оперативную память значительно превышает время исполнения одной инструкции. Для решения этой проблемы были созданы различные техники кэширования и предзагрузки данных в кэш \cite{smith1987design, tse1998cpu}.  Однако на кристалле невозможно разместить слишком сложную логику в виду ограничений на размеры и потребление мощности, к тому же у компилятора или пользователя имеется больше информации о структуре программы чем у аппаратуры во время исполнения. Поэтому уже в 2000х годах начались попытки внедрения оптимизации предзагрузки данных \cite{vanderwiel2000data}. 

Классическим примером такой оптимизации является предзагрузка данных для циклов \cite{chai2021implementation} аккуратный анализ индукционных переменных, расстояния загрузок в цикле и эвристическое определение итераций для предзагрузки циклов позволило авторам статьи \cite{chai2021implementation} получить ускорение в 11 \% с пиковым ускорением в 50 \%  на отдельном тесте для платформы Shenwei. 

Анализ с использованием профиля и аппаратной поддержки записи последнего перехода на процессорах компании Intel позволила авторам еще одной статьи \cite{jamilan2022apt}  имплементировать аналитическую модель с дешевым сбором статистики и быстрым подсчета расстояния предзагрузки данных. Это позволило добиться феноменального ускорения в 30 \% с ускорением до 90 \% на отдельных тестах пакета APT-GET. 

Одним из современных направлений направлением является разработка алгоритмов для предзагрузки косвенных доступов в память. В работе сотрудников Кэмбриджского университета \cite{purkayastha2020llvm}  упоминается разработка алгоритма предзагрузки данных в компиляторе LLVM для косвенного доступа. Их подход нацелен на  системы с высокопроизводительными вычислениями и позволил получить ускорение от 30 \% до 270 \%, к сожалению не были продемонстрированы результаты на тестах specCPU.

Стоит также отметить возможность оптимизации для уменьшение потребления энергии, что является критическим в современных системах. В статье \cite{ekemark2016static} предлагается алгоритм версионирования кода для разных путей с точки зрения потока данных, что позволят сэкономить 10 \% энергии и увеличить производительность на 2 \%.

 
\section{Настройка компилятора}

Одним из современных направлений в области оптимизирующих компиляторов является их автоматическая настройка. Во время компиляции приходится решать очень много NP-полных задач. До сих пор огромное количество алгоритмов компилятора предполагают эвристические параметры и методы. Современное популярное направление направлено на автоматизацию получения этих параметров или их полную замену\cite{leather2020machine}.

В 2016 году вышла статья \cite{ekemark2016static}, в которой авторы с помощью технологии машинного обучения улучшили генератор кода для ускорителя нейронных сетей. Ускорение достигается за счет подборки двух гиперпараметров (количества ядер и схемы объединения слоев). Авторы утверждают, что их подход показывает практически такой же результат, как и метод полного перебора гиперпараметров, однако время, затраченное на подбор, оказывается значительно меньше. 

Работа, вышедшая 2021 году \cite{wei2021compiler}, рассказывает об оптимизации тестов пакетов specCPU 2006 и specCPU 2017 для платформы SHENWEI. Впечатляющие цифры в 14 \% и 25 \% ускорения были получены путем выделения горячих функций и итеративного определения опций компиляции. Такой подход нельзя назвать "честным" поскольку очевидно, при подборе опций использовалась информация о входных данных программы. Однако такие цифры могут служить ориентиром для будущих исследований.

Пространство поиска оптимальных опций достаточно велико, по этому предлагается его сократить \cite{zhu2023compiler}. Для этого вводится алгоритм поиска критических флагов. Интересно, что помимо программы, алгоритм принимает на вход документацию компилятора GCC. Утверждается, что такой подход позволяет получить лучшие цифры по сравнению с другими системами автоматической настройки компилятора.

\section{Оптимизации с использованием профиля}

>pgo without pprofile % https://scholar.google.com/scholar?hl=ru&as_sdt=0,5&as_ylo=2020&q=PGO+without+profile





\FloatBarrier
